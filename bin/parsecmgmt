#!/bin/sh
# shellcheck disable=SC2046,SC2086,SC2236,SC1090,SC2231

# Copyright (C) 2006-2011 Princeton University
# All rights reserved.
# Author: Christian Bienia
#
# parsecmgmt - A tool to manage the PARSEC benchmark suite
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of Princeton University nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY CHRISTIAN BIENIA ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL CHRISTIAN BIENIA BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

set -o errexit
set -o nounset


#################################################################
#                                                               #
#                         CONFIGURATION                         #
#                                                               #
#################################################################

# Define directory of PARSEC benchmark suite
# If $PARSECDIR is not set, the script tries to autodetect the path
#export PARSECDIR=""

# Define platform name to use
# If $PARSECPLAT is not set, the script will automaticaly determine a name
#export PARSECPLAT=""




##### There should be no need to touch anything below here #####

# Output prefix to use
oprefix="[PARSEC]"



#################################################################
#                                                               #
#                           FUNCTIONS                           #
#                                                               #
#################################################################

# parsec_init
#
# Initialize the script
#
# Arguments: none
parsec_init() {
  # We need to hard-wire a few commands because we need them for the path detection
  PWD="pwd"
  BASENAME="basename"
  DIRNAME="dirname"

  # Determine script name
  eval me=$(${BASENAME} $0)

  # Try to find path
  uniquefile=".parsec_uniquefile"
  parsecdir=""
  # Try to autodetect path by looking at path used to invoke this script

  # Try to extract absoute or relative path
  if [ "${0:0:1}" == "/" ]; then
    # Absolute path given
    eval parsecdir=$(${DIRNAME} $(${DIRNAME} $0))
    # Check
    if [ -f "${parsecdir}/${uniquefile}" ]; then
      PARSECDIR=${parsecdir}
    fi
  else
    # No absolute path, maybe relative path?
    eval parsecdir=$(${PWD})/$(${DIRNAME} $(${DIRNAME} $0))
    # Check
    if [ -f "${parsecdir}/${uniquefile}" ]; then
      PARSECDIR=${parsecdir}
    fi
  fi

  # If PARSECDIR is still undefined, we try to guess the path
  if [ -z "${PARSECDIR}" ]; then
    # Check current directory
    if [ -f "./${uniquefile}" ]; then
      parsecdir="$(${PWD})"
      PARSECDIR=${parsecdir}
    fi
  fi
  if [ -z "${PARSECDIR}" ]; then
    # Check next-higher directory
    if [ -f "../${uniquefile}" ]; then
      parsecdir="$(${PWD})/.."
      PARSECDIR=${parsecdir}
    fi
  fi

  export PARSECDIR

  # Eliminate trailing `/.' from PARSECDIR
  PARSECDIR=${PARSECDIR/%\/./}

  ostype="linux"
  hosttype="${HOSTTYPE}"

  # Determine first part of value to use for PARSECPLAT environment variable if not defined by user
  # Note: We will append the compiler configuration to that to get the final value for PARSECPLAT
  hostostype="${hosttype}-${ostype}"

  # Define some global directories
  benchdir=${parsecdir}/pkgs

  # Try to load OS-specific configuration to get binaries and correct arguments
  sysconfig="${PARSECDIR}/config/${ostype}.sysconf"
  source ${sysconfig}

  # Setup environment so PARSEC tools are usable by other programs
  export PATH="${PARSECDIR}/bin:${PATH}"

  # Build list of aliases from package configurations
  list_of_aliases=""
  for file in ${PARSECDIR}/config/packages/*.*.pkgconf; do
    source $file
    # Append unique aliases to global list, build package list for each alias
    for newalias in ${pkg_aliases}; do
      is_duplicate=""
      for alias in ${list_of_aliases}; do
        if [[ "$newalias" == "$alias" ]]; then
          is_duplicate=TRUE
          break
        fi
      done
      # Initialize new aliases
      if [[ "$is_duplicate" != "TRUE" ]]; then
        list_of_aliases="$list_of_aliases $newalias"
        eval alias_${newalias}=\"\"
      fi
      is_duplicate=""
      # Append package to alias list
      eval pkg=$(${BASENAME} $file)
      pkg=${pkg%\.pkgconf}

      # Add prefex ('parsec' or 'splash2')to the pkg
      pkg=${pkg/\./_}

      eval  pkglist=\"\$alias_${newalias}\"
      eval alias_${newalias}=\"$pkglist $pkg\"
    done
  done
}

# process_args
#
# Process args and setup argument-dependent environment
#
# Arguments: all arguments given to the script (i.e. "$@")
process_args() {
  # Default configuration to use
  default_pkgs="parsec splash2 splash2x"
  default_build="gcc"
  default_rundir="${PARSECDIR}"
  default_inputsize="test"
  default_nthreads="1"

  # Usage
  usage="\
Usage: $me -a ACTION [OPTION]...

Manage the installation of the PARSEC benchmark suite.

Options:
    -a ACTION        Specifies the action to perform. See below for a
                     list of valid actions.
    -p PACKAGE       A list of packages or aliases on which the action is to be
                     performed.
    -c CONFIG        Which build configuration to use. Default: '$default_build'
    -d RUNDIR        Use directory RUNDIR as root in which to run the
                     benchmarks.
    -i INPUT         The input to use to run the benchmarks. Default: '$default_inputsize'
    -n THREADS       The minimum number of threads to use. Default: '$default_nthreads'
    -x EXTENSION     Extension to append to platform descriptor string.
                     Default: none
    -k               Keep & use run directory as found, do not unpack inputs for
                     benchmark execution. Assume everything is already set up.
    -m NETMODE       Execution mode for network workloads.
                     NETMODE can be either 'server' or 'client'.
    -t THREADS       The number of user threads talking to the upTCP/IP stack. Default: '1'
    -r THREADS       The number of TCP/IP protocol receving threads. Default: '1'
    -l               Disable log.
    -h               Displays this help message.


Actions:
    'build'          Builds and installs the specified packages.
    'run'            Runs the specified packages.
    'clean'          Removes all files generated during the build and run phase
                     of the listed packages for the current platform, but
                     leaves the installed files untouched.
    'uninstall'      Removes the installed files of the listed packages for the
                     current platform.
    'fullclean'      Like 'clean', but for all architectures.
    'fulluninstall'  Like 'uninstall', but for all architectures.
    'status'         Shows a summary of the current status of the PARSEC
                     installation.
    'info'           List available packages and configurations."

  # Define valid actions
  valid_actions="build run clean uninstall fullclean fulluninstall status info"

  # Parse arguments
  parsemode="none"
  need_arg_for=""
  action=""
  pkgs=""
  build=""
  rundir=""
  inputsize=""
  netmode=""
  nthreads=""
  extension=""
  extcmd=""
  keep_rundir=""
  while [ ! -z "$1" ]; do
    arg="$1"
    case "${arg}" in
      "-a" )
        if [ ! -z "${need_arg_for}" ]; then
          echo "${oprefix} Error: ${parsemode} expected between '${need_arg_for}' and '-a'"
          echo "${usage}"
          exit 1
        fi
        if [ ! -z "${action}" ]; then
          echo "${oprefix} Error: Two actions specified"
          exit 1
        fi
        need_arg_for="-a"
        parsemode="ACTION";;
      "-p" )
        if [ ! -z "${need_arg_for}" ]; then
          echo "${oprefix} Error: ${parsemode} expected between '${need_arg_for}' and '-p'"
          echo "${usage}"
          exit 1
        fi
        need_arg_for="-p"
        parsemode="PKGS";;
      "-i" )
        if [ ! -z "${need_arg_for}" ]; then
          echo "${oprefix} Error: ${parsemode} expected between '${need_arg_for}' and '-i'"
          echo "${usage}"
          exit 1
        fi
        need_arg_for="-i"
        parsemode="INPUT";;
      "-n" )
        if [ ! -z "${need_arg_for}" ]; then
          echo "${oprefix} Error: ${parsemode} expected between '${need_arg_for}' and '-n'"
          echo "${usage}"
          exit 1
        fi
        need_arg_for="-n"
        parsemode="NTHREADS";;
      "-h" )
        echo "${usage}"
        exit 0;;
     *    )
        if [ ${arg:0:1} == "-" ]; then
          echo "${oprefix} Error: Unknown argument '${arg}'"
          echo "${usage}"
          exit 1
        fi
        need_arg_for=""
        case "${parsemode}" in
          "ACTION"   )
            parsemode="none"
            # Check whether specified action is valid
            is_valid=""
            for valid_action in ${valid_actions}; do
              if [ "${arg}" == "${valid_action}" ]; then
                is_valid="TRUE"
                break
              fi
            done
            if [ -z "$is_valid" ]; then
              echo "${oprefix} Error: Unknown action '${arg}'."
              echo "${usage}"
              exit 1
            fi
            action="${arg}";;
          "PKGS"   )
            # Check whether specified package is valid
            is_valid=""
            # Is it a recognized alias?
            tmparg=""
            tmparg=${arg/\./_} #arg could be "splash2" or "splash2.fmm"
            if [ ${tmparg} == ${arg} ]; then
                eval tmparg="\"\${alias_${arg}}\""
                if [ ! -z "${tmparg}" ]; then
                    is_valid="TRUE"
                else # parsec pkg
                    tmparg=parsec_${arg}
                    arg=parsec.${arg}
                fi
            fi
            # Is it a recognized package?
            if [[ -e "${PARSECDIR}/config/packages/${arg}.pkgconf" ]]; then
              is_valid="TRUE"
            fi
            # Interpret result
            if [ -z "$is_valid" ]; then
              echo "${oprefix} Error: Invalid package '${arg}'."
              exit 1
            fi
            pkgs="${pkgs} ${tmparg}";;
          "CONFIG"   )
            parsemode="none"
            # Check whether specified config file exists
            buildfile="${PARSECDIR}/config/${arg}.bldconf"
            if [ ! -f "${buildfile}" ]; then
              echo "${oprefix} Error: Cannot find build configuration file '${buildfile}'."
              exit 1
            fi
            build="${arg}";;
          "RUNDIR"   )
           parsemode="none"
            # Check whether specified run directory exists
            if [ ! -d "${arg}" ]; then
              echo "${oprefix} Error: Cannot find directory '${arg}'."
              exit 1
            fi
            rundir="${arg}";;
          "INPUT"    )
            parsemode="none"
            # Check whether specified input set exists
            runconfigfile="${PARSECDIR}/config/${arg}.runconf"
            if [ ! -f "${runconfigfile}" ]; then
              echo "${oprefix} Error: Unknown input set '${arg}'."
              exit 1
            fi
            inputsize="${arg}";;
          "NTHREADS" )
            parsemode="none"
            declare -i nthreads
            nthreads="${arg}"
            # Note: This check also filters out strings (nthreads==0 in that case)
            if [ "${nthreads}" -lt "1" ]; then
              echo "${oprefix} Error: Illegal number of threads: '${arg}'."
              echo "${usage}"
              exit 1
            fi;;
        esac;;
    esac

    shift
  done
  if [ ! -z "${need_arg_for}" ]; then
    echo "${oprefix} Error: ${parsemode} expected after '${need_arg_for}'"
    echo "${usage}"
    exit 1
  fi

  # Make sure we have an action and at least one package
  if [ -z "${action}" ]; then
    echo "${oprefix} Error: No action specified."
    echo "${usage}"
    exit 1
  fi

  if [ -z "${pkgs}" ]; then
    # Is it a recognized alias?
    for arg in ${default_pkgs} ; do
            tmparg=""
            tmparg=${arg/\./_} #arg could be "splash2" or "splash2.fmm"
            if [ ${tmparg} == ${arg} ]; then
                eval tmparg="\"\${alias_${arg}}\""
                if [ -z "${tmparg}" ]; then
                    tmparg=parsec_${arg}
                    arg=parsec.${arg}
                fi
            fi
            pkgs="${pkgs} ${tmparg}"
    done
  fi

  # Set NTHREADS
  if [ -z "${nthreads}" ]; then
    # Use default value
    NTHREADS="${default_nthreads}"
  else
    NTHREADS="${nthreads}"
  fi

  # Set rundir
  if [ -z "${rundir}" ]; then
    # Use default value
    rundir="${default_rundir}"
  fi

  # Set input size
  if [ -z "${inputsize}" ]; then
    # Use default value
    inputsize="${default_inputsize}"
  fi

  # Define PARSECPLAT, if not set by user
  if [ -z "${PARSECPLAT}" ]; then
    PARSECPLAT=${hostostype}.${build}
  else
    PARSECPLAT=${PARSECPLAT}.${build}
  fi
  # Append extension if specified
  if [ ! -z "${extension}" ]; then
    PARSECPLAT=${PARSECPLAT}.${extension}
  fi

  export PARSECPLAT
  # Load build configuration
  if [ "${action}" == "build" -o "${action}" == "run" ]; then
    buildfile="${PARSECDIR}/config/${build}.bldconf"
    if [ -f "${buildfile}" ]; then
      source ${buildfile}
    else
      echo "${oprefix} Error: Cannot find build configuration file '${buildfile}'."
      exit 1
    fi
  fi

  # Expand aliases to get full list of packages to build
  # there are three kinds of token in $pkgs:
  #    1) parsec_pthread, parsec_opemmp, etc. alias, remove "parsec_" and just expand them
  #    2) parsec_streamcluster etc. not alias but parsec workloads, just add them
  #    3) splash2_raytrace, splash2_xxx. not alias but splash2 workloads, just add them
  expanded_aliases=""
  for token in ${pkgs}; do
    # Is it a recognized alias?
    tmpbench=${token:0:5}
    if [ $tmpbench == "parsec" ]; then
        tmppkg=${token:7}
        eval temp="\"\${alias_${tmppkg}}\""
        if [ ! -z "${temp}" ]; then
          # Yes it is, expand alias
          expanded_aliases="${expanded_aliases} ${temp}"
        else
          # Otherwise keep it in the list
          expanded_aliases="${expanded_aliases} ${token}"
        fi
    else
        expanded_aliases="${expanded_aliases} ${token}"
    fi
  done

  # Rebuild list with packages, remove duplicate packages
  pkgs=""
  pkgs_nonapps="${alias_tools} ${alias_libs}"
  for pkg in $expanded_aliases; do
    is_included=""
    # restore to xxxx.xxxx format
    tmppkg=${pkg/_/\.}
    for dummy in $pkgs; do
      if [ "$tmppkg" == "$dummy" ]; then
        is_included="TRUE"
        break
      fi
    done

    if [ "${action}" == "run" ]; then
        for tmppkg2 in ${pkgs_nonapps}; do
           tmppkg3=${tmppkg2/_/\.}
           if [ "${tmppkg3}" == "$tmppkg" ]; then
                is_included="TRUE"
                break
           fi
        done
    fi

    if [ -z "$is_included" ]; then
      pkgs="${pkgs} ${tmppkg}"
    fi
  done
}

# run_benchmark
#
# Run the specified benchmarks
#
# Arguments: $1 - The benchmark name
#            $2 - Which input to use
#            $3 - The run directory root
run_benchmark() {
  benchmark=$1
  inputsize=$2
  rundir=$3

  echo "${oprefix} [========== Running benchmark ${benchmark} ==========]"

  # Load package configuration
  source ${PARSECDIR}/config/packages/${benchmark}.pkgconf

  # Define benchmark-specific directories
  if [ -z "${pkg_group}" ]; then
    echo "${oprefix} Error: Group of benchmark '${benchmark}' is unknown."
    exit 1
  fi


  # determine top directory
  bench=`expr match ${benchmark} '\(.*\.\)'`
  eval pkgname="${benchmark#${bench}}"
  bench=${bench%\.}

  # deal with some specific cases
  if [ ${bench} == "parsec" ]; then
      eval benchdir="pkgs"
  else
      eval benchdir="ext/${bench}"
  fi

  # specific cases end
  #

  bmrundir="${rundir}/${benchdir}/${pkg_group}/${pkgname}/run"
  bmdir="${PARSECDIR}/${benchdir}/${pkg_group}/${pkgname}"
  bminputdir="${bmdir}/inputs"
  bmoutputdir="${bmdir}/outputs"
  bminstdir="${bmdir}/inst/${PARSECPLAT}"
  bmparsecdir="${bmdir}/parsec"

  # Check whether selected input size is available
  if [ ! -f "${PARSECDIR}/config/${inputsize}.runconf" ]; then
    echo "${oprefix} Error: Selected input size not available."  2>&1
    exit 1
  fi

  # Source package run configuration
  if [ ! -f "${bmparsecdir}/${inputsize}.runconf" ]; then
    echo "${oprefix} Error: Cannot find run configuration '${inputsize}.runconf' for package ${benchmark}." 2>&1
    exit 1
      get_topdir "${package}"
  else
    source ${bmparsecdir}/${inputsize}.runconf
  fi

  # Determine binary
  bmexec_suffix=${run_exec}
  if [ -z "${bmexec_suffix}" ]; then
    echo "${oprefix} Variable 'bench_exec_${benchmark}' for package '${benchmark}' has not been set."
    exit 1
  fi
  bmexec="${bminstdir}/${bmexec_suffix}"
  if [ ! -x "${bmexec}" ]; then
    echo "${oprefix} Error: Binary '${bmexec}' of package '${benchmark}' cannot be found."
    exit 1
  fi

  # Determine output archive
  bmoutput="${bmoutputdir}/output_${inputsize}.tar"
  #if [ ! -f "${bmoutput}" ]; then
  #  echo "${oprefix} Error: Output archive '${bmoutput}' of package '${benchmark}' cannot be found."
  #  exit 1
  #fi

  if [ "${keep_rundir}" == "yes" ]; then
    # Keep run directory, just check that it exists
    if [ ! -d "${bmrundir}" ]; then
      echo "${oprefix} Error: Cannot keep run directory because it does not exist."
      exit 1
    fi
    echo "${oprefix} Keeping old run directory."
    pushd "${bmrundir}" > /dev/null
  else
    # Set up run directory
    if [ -d "${bmrundir}" ]; then
      echo "${oprefix} Deleting old run directory."
      ${RM} ${bmrundir}
    fi

    echo "${oprefix} Setting up run directory."
    ${MKDIR} ${bmrundir}
    pushd "${bmrundir}" > /dev/null

    # Determine input archive
    bminput="${bminputdir}/input_${inputsize}.tar"
    if [ ! -f "${bminput}" ]; then
      echo "${oprefix} No archive for input '${inputsize}' available, skipping input setup."
    else
      echo "${oprefix} Unpacking benchmark input '${inputsize}'."
      ${UNTAR} ${bminput}
    fi
  fi

  # Execute
  bmexec_args=${run_args}
  echo "${oprefix} Running '${cmd}':"
  echo "${oprefix} [---------- Beginning of output ----------]"
  eval ${cmd}
  echo "${oprefix} [----------    End of output    ----------]"
}

get_topdir() {
  if [ -z "$1" ]; then
    echo "${oprefix} Error: get_topdir with no arguments."
    exit 1
  fi
  benchmark=$1

  # determine top directory
  benchdir=""
  pkgname=""

  bench=`expr match ${benchmark} '\(.*\.\)'`
  eval pkgname="${benchmark#${bench}}"
  bench=${bench%\.}

  if [ ${bench} == "parsec" ]; then
      benchdir="pkgs"
  else
      eval benchdir="ext\/${bench}"
  fi
}

#################################################################
#                                                               #
#                             MAIN                              #
#                                                               #
#################################################################

# Execute functions to setup environment
parsec_init
process_args "$@"

# Now we take decisive action
case ${action} in
  "run"           )
    echo "${oprefix} Benchmarks to run: ${pkgs}" 2>&1

    export LD_LIBRARY_PATH="${CC_HOME}/lib:${CC_HOME}/lib64"

    # Prepare LD_LIBRARY_PATH
    if [ -n "${LD_LIBRARY_PATH}" ]; then
      LD_LIBRARY_PATH+=":${LD_LIBRARY_PATH}"
    fi

    # Execute all benchmarks
    for benchmark in ${pkgs}; do
      # Load package configuration
      source ${PARSECDIR}/config/packages/${benchmark}.pkgconf

      run_benchmark "${benchmark}" "${inputsize}" "${rundir}"
    done

    echo "${oprefix} Done.";;
  *           )
    echo "${oprefix} Error: Unknown action '${action}'."
    exit 1;;
esac

exit 0
